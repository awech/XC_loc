

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>XC_loc.XC_main &mdash; XC_loc 1.0.6 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> XC_loc
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">2. enveloc Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../setup.html">3. Usage overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">4. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../output.html">5. Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xcor.html">6. <em>XCOR</em> object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../event_list.html">7. <em>event_list</em> object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../detections.html">8. <em>detections</em> object</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">XC_loc</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>XC_loc.XC_main</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for XC_loc.XC_main</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">obspy.taup</span> <span class="kn">import</span> <span class="n">TauPyModel</span>
<span class="kn">from</span> <span class="nn">obspy.geodetics</span> <span class="kn">import</span> <span class="n">locations2degrees</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">XC_loc.xcorr_Tools</span> <span class="k">as</span> <span class="nn">xcorr_Tools</span>
<span class="kn">import</span> <span class="nn">XC_loc.xloc_Tools</span> <span class="k">as</span> <span class="nn">xloc_Tools</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">obspy.geodetics.base</span> <span class="kn">import</span> <span class="n">gps2dist_azimuth</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>


<span class="k">def</span> <span class="nf">progress</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Method to display status bar when calculating traveltimes</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	count : int, required</span>
<span class="sd">		number of current iteration</span>
<span class="sd">	total : int, required</span>
<span class="sd">		number of iterations required</span>
<span class="sd">	status : str, optional</span>
<span class="sd">		string to be printed to screen with status message</span>

<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">bar_len</span> <span class="o">=</span> <span class="mi">35</span>
	<span class="n">filled_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">bar_len</span> <span class="o">*</span> <span class="n">count</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">total</span><span class="p">)))</span>
	<span class="n">percents</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="n">count</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">total</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span> <span class="o">*</span> <span class="n">filled_len</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">bar_len</span> <span class="o">-</span> <span class="n">filled_len</span><span class="p">)</span>
	<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Calculating travel times |</span><span class="si">{}</span><span class="s1">| </span><span class="si">{}{}</span><span class="s1"> </span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">percents</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">))</span>
	<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>  <span class="c1"># As suggested by Rom Ruben (see: http://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console/27871113#comment50529068_27871113)</span>


<span class="k">def</span> <span class="nf">checkvalue</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to switch from &#39;None&#39; to NaN</span>
<span class="sd">	</span>
<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	value : number, requred</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
		<span class="k">pass</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
	<span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">latlon2xy</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to change lat/lon to x/y for distance calulation in clustering method</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	loc : obj, required</span>
<span class="sd">		location object returned from `XC_locate`</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">obspy.geodetics.base</span> <span class="kn">import</span> <span class="n">gps2dist_azimuth</span>
	<span class="n">lats</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">get_lats</span><span class="p">())</span>
	<span class="n">lons</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">get_lons</span><span class="p">())</span>

	<span class="n">y0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
	<span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>

	<span class="n">x</span><span class="o">=</span><span class="p">[]</span>
	<span class="n">y</span><span class="o">=</span><span class="p">[]</span>
	<span class="k">for</span> <span class="n">lat</span><span class="p">,</span><span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span><span class="n">lons</span><span class="p">):</span>

	    <span class="n">a</span><span class="o">=</span><span class="n">gps2dist_azimuth</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.</span>
	    <span class="k">if</span> <span class="n">lat</span><span class="o">&lt;</span><span class="n">y0</span><span class="p">:</span>
	    	<span class="n">a</span><span class="o">=-</span><span class="n">a</span>
	    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	    <span class="n">a</span><span class="o">=</span><span class="n">gps2dist_azimuth</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">,</span><span class="n">lat</span><span class="p">,</span><span class="n">x0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.</span>
	    <span class="k">if</span> <span class="n">lon</span><span class="o">&lt;</span><span class="n">x0</span><span class="p">:</span>
	    	<span class="n">a</span><span class="o">=-</span><span class="n">a</span>
	    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">check_edgeproblems</span><span class="p">(</span><span class="n">edge_control</span><span class="p">,</span><span class="n">st_tmp</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to remove traces whose peak amplitude occur with &#39;edge_control&#39; percent</span>
<span class="sd">	of the window edge</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">edge</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">edge_control</span><span class="o">*</span><span class="n">st_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st_tmp</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">&lt;=</span><span class="n">edge</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">&gt;=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="o">-</span><span class="n">edge</span><span class="p">:</span>
			<span class="n">st_tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">st_tmp</span>


<span class="k">def</span> <span class="nf">XC_locate</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="n">XC</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Main location function. Called internally from `XCOR` class&#39;s `locate()` method</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	win : list, required</span>
<span class="sd">		2 element list of obspy UTCDateTime start and end times for which to cut out a window of seismic data</span>
<span class="sd">	XC : obj, required</span>
<span class="sd">		object created by `XCOR` class</span>

<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">st_tmp</span><span class="o">=</span><span class="n">XC</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">  --  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y.%m.</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">),</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y.%m.</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)))</span>

	<span class="sd">&quot;&quot;&quot; Remove traces with zero-ed out data &quot;&quot;&quot;</span>
	<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st_tmp</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">&lt;</span><span class="mf">1e-15</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">XC</span><span class="o">.</span><span class="n">_waveform_loc</span><span class="p">:</span>
			<span class="n">st_tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XC</span><span class="o">.</span><span class="n">sta_min</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING FROM XC_loc: too many traces with no data&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">))</span> 	<span class="c1"># return latitude, longitude, depth # return because these envelopes suck.</span>

	<span class="sd">&quot;&quot;&quot; Remove traces with flagged gaps &quot;&quot;&quot;</span>
	<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st_tmp</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">==</span><span class="n">XC</span><span class="o">.</span><span class="n">_gap_value</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">XC</span><span class="o">.</span><span class="n">_waveform_loc</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gap in </span><span class="si">{}</span><span class="s1"> | Removing station...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
			<span class="n">st_tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XC</span><span class="o">.</span><span class="n">sta_min</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING FROM XC_loc: too many traces with no data&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">))</span> 	<span class="c1"># return latitude, longitude, depth # return because these envelopes suck.</span>


	<span class="sd">&quot;&quot;&quot; Remove traces with triggers within time window &quot;&quot;&quot;</span>
	<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st_tmp</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="s1">&#39;triggers&#39;</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">triggers</span><span class="o">&gt;=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">triggers</span><span class="o">&lt;=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)):</span>
				<span class="n">st_tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XC</span><span class="o">.</span><span class="n">sta_min</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING FROM XC_loc: too many traces with triggers&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">))</span> 	<span class="c1"># return latitude, longitude, depth # return because these envelopes suck.</span>


	<span class="c1">####################################################</span>
	<span class="sd">&quot;&quot;&quot;	Check for traces with peaks at or near the edge.</span>
<span class="sd">		Remove problem traces and check that</span>
<span class="sd">		enough stations remain  &quot;&quot;&quot;</span>
	<span class="c1">####################################################</span>
	<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">_edge_control</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">XC</span><span class="o">.</span><span class="n">_waveform_loc</span><span class="p">:</span>
		<span class="n">st_tmp</span><span class="o">=</span><span class="n">check_edgeproblems</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">_edge_control</span><span class="p">,</span><span class="n">st_tmp</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st_tmp</span><span class="p">])</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">XC</span><span class="o">.</span><span class="n">sta_min</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING FROM XC_loc: too many traces with peaks at edge of window&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">st_tmp</span><span class="p">))</span> 	<span class="c1"># return latitude, longitude, depth # return because these envelopes suck.</span>
	<span class="c1">####################################################</span>
	<span class="c1">####################################################</span>

	<span class="c1">####################################################</span>
	<span class="sd">&quot;&quot;&quot; perform initial cross-correlation of all traces &quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">detrend</span><span class="p">:</span>
		<span class="n">st_tmp</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s1">&#39;demean&#39;</span><span class="p">)</span>
	<span class="n">CC</span> <span class="o">=</span> <span class="n">xcorr_Tools</span><span class="o">.</span><span class="n">initial_correlation</span><span class="p">(</span><span class="n">XC</span><span class="p">,</span><span class="n">st_tmp</span><span class="p">)</span>
	<span class="sd">&quot;&quot;&quot; return if not enough stations remain &quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">CC</span><span class="p">[</span><span class="s1">&#39;err&#39;</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING FROM XC_loc: need at least </span><span class="si">{:.0f}</span><span class="s1"> stations to correlate above </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">sta_min</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">Cmin</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">CC</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">]))</span> 	<span class="c1"># return latitude, longitude, depth # return because these envelopes suck.	</span>
	<span class="c1">####################################################</span>
	<span class="c1">####################################################</span>

	<span class="sd">&quot;&quot;&quot; make working copy of cross-correlation dictionary &quot;&quot;&quot;</span>
	<span class="n">CCrm</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

	<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">drop_key</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
	<span class="sd">&quot;&quot;&quot; you&#39;re going stay in the loop if it is the first time (count==0) or </span>
<span class="sd">	    while there are stations to remove and the data need relocated from</span>
<span class="sd">	    interactive mode &quot;&quot;&quot;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">drop_key</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">count</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>

		<span class="n">bstrap_lat</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
		<span class="n">bstrap_lon</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
		<span class="n">bstrap_dep</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
		
		<span class="sd">&quot;&quot;&quot; remove stations and values from cc-matrix if stations</span>
<span class="sd">		    get removed during interactive location process   &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drop_key</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Removing stations.&#39;</span><span class="p">)</span>
			<span class="n">CCrm</span> <span class="o">=</span> <span class="n">xcorr_Tools</span><span class="o">.</span><span class="n">remove_stations</span><span class="p">(</span><span class="n">CCrm</span><span class="p">,</span><span class="n">XC</span><span class="p">,</span><span class="n">drop_key</span><span class="p">)</span>

		<span class="n">nan_count</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="sd">&quot;&quot;&quot; Loop for bootstrap iterations. Last iteration is uses all of the data. &quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">bstrap</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">):</span>

			<span class="c1">####################################################</span>
			<span class="sd">&quot;&quot;&quot; Check if you&#39;ve had too many bad (NaN) bootstrap locations &quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="n">nan_count</span> <span class="o">&gt;=</span> <span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Too many NaN bootstrap locations.&#39;</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">]))</span>
			<span class="c1">####################################################</span>
			<span class="c1">####################################################</span>


			<span class="c1">####################################################</span>
			<span class="sd">&quot;&quot;&quot; make boostrap working copy of cross-correlation dictionary &quot;&quot;&quot;</span>
			<span class="n">CCnew</span><span class="o">=</span><span class="n">CCrm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="sd">&quot;&quot;&quot; If not the last iteration, throw away % of cc-matrix data  &quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="n">bstrap</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
				<span class="n">CCnew</span> <span class="o">=</span> <span class="n">xcorr_Tools</span><span class="o">.</span><span class="n">bootstrap_CC</span><span class="p">(</span><span class="n">CCrm</span><span class="p">,</span><span class="n">XC</span><span class="p">)</span>
			<span class="sd">&quot;&quot;&quot; Not enough stations remain? &quot;&quot;&quot;</span>	
			<span class="k">if</span> <span class="n">CCnew</span><span class="p">[</span><span class="s1">&#39;err&#39;</span><span class="p">]:</span>
				<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING FROM XC_loc: need at least </span><span class="si">{:.0f}</span><span class="s1"> stations to correlate above </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">sta_min</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">Cmin</span><span class="p">))</span>				
				<span class="sd">&quot;&quot;&quot; Continue if bootstrap loop and iterate # of bad bstrap locations &quot;&quot;&quot;</span>
				<span class="k">if</span> <span class="n">bstrap</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
					<span class="n">nan_count</span><span class="o">=</span><span class="n">nan_count</span><span class="o">+</span><span class="mi">1</span>
					<span class="k">continue</span>
				<span class="c1">### Return empty location object if it is last iteration   &quot;&quot;&quot;</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">]))</span> 	<span class="c1"># return latitude, longitude, depth # return because these envelopes suck.</span>
			<span class="c1">####################################################</span>
			<span class="c1">####################################################</span>


			<span class="sd">&quot;&quot;&quot; Do a grid search to get a hypocenter &quot;&quot;&quot;</span>
			<span class="n">tmp_lat</span><span class="p">,</span> <span class="n">tmp_lon</span><span class="p">,</span> <span class="n">tmp_dep</span><span class="p">,</span> <span class="n">misfit</span> <span class="o">=</span> <span class="n">xloc_Tools</span><span class="o">.</span><span class="n">CCtoHypocenter</span><span class="p">(</span><span class="n">CCnew</span><span class="p">,</span><span class="n">XC</span><span class="p">)</span>
			<span class="k">if</span> <span class="s1">&#39;windows&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">XC</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="n">XC</span><span class="o">.</span><span class="n">_num_processors</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">XC</span><span class="o">.</span><span class="n">misfit</span><span class="o">=</span><span class="n">misfit</span>


			<span class="c1">####################################################</span>
			<span class="sd">&quot;&quot;&quot; Check if location is on grid edge &quot;&quot;&quot;</span>
			<span class="n">edge_check</span><span class="o">=</span><span class="kc">False</span>
			<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]:</span>
					<span class="n">edge_check</span><span class="o">=</span><span class="kc">True</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]:</span>
					<span class="n">edge_check</span><span class="o">=</span><span class="kc">True</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">tmp_lon</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]:</span>
					<span class="n">edge_check</span><span class="o">=</span><span class="kc">True</span>
			<span class="k">if</span> <span class="n">edge_check</span><span class="p">:</span>	
				<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;On grid edge!! No location for you.&#39;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">bstrap</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
					<span class="n">nan_count</span><span class="o">=</span><span class="n">nan_count</span><span class="o">+</span><span class="mi">1</span>
					<span class="k">continue</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">location</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">]))</span>
			<span class="c1">####################################################</span>
			<span class="c1">####################################################</span>



			<span class="sd">&quot;&quot;&quot; Regrid if XC.regrid==True &quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">regrid</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
					<span class="n">tmp_lat</span><span class="p">,</span> <span class="n">tmp_lon</span><span class="p">,</span> <span class="n">tmp_dep</span> <span class="o">=</span> <span class="n">xloc_Tools</span><span class="o">.</span><span class="n">regridHypocenter_rotated</span><span class="p">(</span><span class="n">XC</span><span class="p">,</span><span class="n">misfit</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">tmp_lat</span><span class="p">,</span> <span class="n">tmp_lon</span><span class="p">,</span> <span class="n">tmp_dep</span> <span class="o">=</span> <span class="n">xloc_Tools</span><span class="o">.</span><span class="n">regridHypocenter</span><span class="p">(</span><span class="n">XC</span><span class="p">,</span><span class="n">misfit</span><span class="p">)</span>


			<span class="c1">####################################################</span>
			<span class="sd">&quot;&quot;&quot; Append bootstrap location info if not last iteration &quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="n">bstrap</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;...bootstrap...Latitude: </span><span class="si">{:.3f}</span><span class="s1">, Longitude: </span><span class="si">{:.3f}</span><span class="s1">, Depth </span><span class="si">{:.1f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">tmp_lon</span><span class="p">,</span><span class="n">tmp_dep</span><span class="p">))</span>
				<span class="n">bstrap_lat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">)</span>
				<span class="n">bstrap_lon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_lon</span><span class="p">)</span>
				<span class="n">bstrap_dep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_dep</span><span class="p">)</span>
			<span class="c1">### Last iteration. Set location object info with this location. &quot;&quot;&quot;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">loc</span><span class="o">=</span><span class="n">location</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">longitude</span><span class="o">=</span><span class="n">tmp_lon</span><span class="p">,</span><span class="n">depth</span><span class="o">=</span><span class="n">tmp_dep</span><span class="p">,</span><span class="n">starttime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">endtime</span><span class="o">=</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">channels</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">channel_list</span><span class="p">(</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">]))</span>
				<span class="sd">&quot;&quot;&quot; Optionally calculate reduced displacement&quot;&quot;&quot;</span>
				<span class="k">if</span> <span class="s1">&#39;raw_traces&#39;</span> <span class="ow">in</span> <span class="n">XC</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
					<span class="n">loc</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">XC</span><span class="p">,</span><span class="n">XC</span><span class="o">.</span><span class="n">raw_traces</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span><span class="n">loc</span><span class="o">.</span><span class="n">endtime</span><span class="p">))</span>
				<span class="sd">&quot;&quot;&quot; If bootstraping at all, calculate scatter from bootstrap locations &quot;&quot;&quot;</span>
				<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="n">dx</span><span class="p">,</span><span class="n">dz</span> <span class="o">=</span> <span class="n">xloc_Tools</span><span class="o">.</span><span class="n">location_scatter</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">bstrap_lat</span><span class="p">,</span><span class="n">bstrap_lon</span><span class="p">,</span><span class="n">bstrap_dep</span><span class="p">)</span>
					<span class="n">loc</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="o">=</span><span class="n">dx</span>
					<span class="n">loc</span><span class="o">.</span><span class="n">vertical_scatter</span><span class="o">=</span><span class="n">dz</span>
					<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--Location--</span><span class="se">\n</span><span class="s1">Latitude: </span><span class="si">{:.3f}</span><span class="s1">, Longitude: </span><span class="si">{:.3f}</span><span class="se">\t</span><span class="s1"> +/- </span><span class="si">{:.1f}</span><span class="se">\n</span><span class="s1">--Depth--</span><span class="se">\n</span><span class="si">{:.1f}</span><span class="s1"> +/- </span><span class="si">{:.1f}</span><span class="s1"> km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">tmp_lon</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">tmp_dep</span><span class="p">,</span><span class="n">dz</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--Location--</span><span class="se">\n</span><span class="s1">Latitude: </span><span class="si">{:.3f}</span><span class="s1">, Longitude: </span><span class="si">{:.3f}</span><span class="s1">, Depth: </span><span class="si">{:.1f}</span><span class="s1"> km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_lat</span><span class="p">,</span><span class="n">tmp_lon</span><span class="p">,</span><span class="n">tmp_dep</span><span class="p">))</span>
			<span class="c1">####################################################</span>
			<span class="c1">####################################################</span>


		<span class="c1">####################################################</span>
		<span class="sd">&quot;&quot;&quot; Done with bootstrap loop. Plot &amp; interact &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">XC</span><span class="o">.</span><span class="n">plot</span> <span class="ow">and</span> <span class="n">XC</span><span class="o">.</span><span class="n">_num_processors</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="kn">from</span> <span class="nn">XC_loc.XC_plotting</span> <span class="kn">import</span> <span class="n">XC_plot</span>
			<span class="sd">&quot;&quot;&quot; set up some variables for plotting &quot;&quot;&quot;</span>
			<span class="n">CC1</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][:,</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;indx&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">!=</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;indx&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]]</span>
			<span class="n">Nseis0</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">CCrm</span><span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">])</span>
			<span class="n">plot_loc</span><span class="o">=</span><span class="n">loc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="n">plot_loc</span><span class="o">.</span><span class="n">bstrap_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bstrap_lat</span><span class="p">)</span>
			<span class="n">plot_loc</span><span class="o">.</span><span class="n">bstrap_lon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bstrap_lon</span><span class="p">)</span>
			<span class="n">CCshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nseis0</span><span class="o">*</span><span class="p">(</span><span class="n">Nseis0</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">XC</span><span class="o">.</span><span class="n">_mlag</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># index into cross-corrleation array</span>
			<span class="sd">&quot;&quot;&quot; Call plotting routine. Return plot_opt variable to see if </span>
<span class="sd">			    we need to relocate &quot;&quot;&quot;</span>
			<span class="n">plot_opt</span> <span class="o">=</span> <span class="n">XC_plot</span><span class="p">(</span><span class="n">CCrm</span><span class="p">,</span><span class="n">XC</span><span class="p">,</span><span class="n">CC1</span><span class="p">,</span><span class="n">misfit</span><span class="p">,</span><span class="n">plot_loc</span><span class="p">)</span>
			<span class="n">drop_key</span> <span class="o">=</span> <span class="n">plot_opt</span><span class="p">[</span><span class="s1">&#39;krm&#39;</span><span class="p">]</span>
			<span class="sd">&quot;&quot;&quot; relocate with some stations removed &quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="n">plot_opt</span><span class="p">[</span><span class="s1">&#39;relocate&#39;</span><span class="p">]:</span>
				<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
			<span class="k">elif</span> <span class="n">plot_opt</span><span class="p">[</span><span class="s1">&#39;restart&#39;</span><span class="p">]:</span>
				<span class="sd">&quot;&quot;&quot; relocate with original station list &quot;&quot;&quot;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
				<span class="n">CCrm</span>  <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="n">drop_key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
		<span class="c1">####################################################</span>
		<span class="c1">####################################################</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="sd">&quot;&quot;&quot; done with while loop looking for revomved station &quot;&quot;&quot;</span>

	<span class="k">return</span> <span class="n">loc</span>


<span class="k">class</span> <span class="nc">location</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; Define a location object &quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">channels</span><span class="o">=</span><span class="p">[],</span><span class="n">reduced_displacement</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">latitude</span>  <span class="o">=</span> <span class="n">checkvalue</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">checkvalue</span><span class="p">(</span><span class="n">longitude</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">depth</span>     <span class="o">=</span> <span class="n">checkvalue</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">horizontal_scatter</span> <span class="o">=</span> <span class="n">checkvalue</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vertical_scatter</span>   <span class="o">=</span> <span class="n">checkvalue</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">starttime</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">endtime</span>  <span class="o">=</span> <span class="n">endtime</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">reduced_displacement</span> <span class="o">=</span> <span class="n">reduced_displacement</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
		<span class="n">A</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">+</span><span class="s1">&#39;=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)))</span>
		<span class="k">return</span> <span class="s1">&#39;location(&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

	<span class="k">def</span> <span class="nf">station_latlons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; return stas, np.array(lats), np.array(lons) for this location &quot;&quot;&quot;</span>
		<span class="n">lats</span><span class="o">=</span><span class="p">[]</span>
		<span class="n">lons</span><span class="o">=</span><span class="p">[]</span>
		<span class="n">stas</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
			<span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">stas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

		<span class="k">return</span> <span class="n">stas</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">event_list</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; Define an events object, which is a list of location objects &quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">events</span><span class="o">=</span><span class="p">[]):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">events</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s1">&#39;event_list object containing </span><span class="si">{:.0f}</span><span class="s1"> events&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">get_lats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return numpy array of all location latitudes in the list &quot;&quot;&quot;</span>
		<span class="n">lats</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">latitude</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">lats</span>

	<span class="k">def</span> <span class="nf">get_lons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return numpy array of all location longitudes in the list &quot;&quot;&quot;</span>
		<span class="n">lons</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">longitude</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">lons</span>

	<span class="k">def</span> <span class="nf">get_depths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return numpy array of all location depths in the list &quot;&quot;&quot;</span>
		<span class="n">lons</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">depth</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">lons</span>

	<span class="k">def</span> <span class="nf">get_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return two numpy arrays of all location window start and end times in the list &quot;&quot;&quot;</span>
		<span class="n">starttimes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">starttime</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="n">endtimes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">endtime</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">starttimes</span><span class="p">,</span> <span class="n">endtimes</span>

	<span class="k">def</span> <span class="nf">get_reduced_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return all location reduced displacements in the events list as a numpy array &quot;&quot;&quot;</span>
		<span class="n">reduced_displacement</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">reduced_displacement</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">reduced_displacement</span>

	<span class="k">def</span> <span class="nf">get_numchannels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Returns a numpy array of number of channels used in each location &quot;&quot;&quot;</span>
		<span class="n">num</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">station_latlons</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">num</span>

	<span class="k">def</span> <span class="nf">get_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return a list of all stations used in all locations in event list &quot;&quot;&quot;</span>
		<span class="n">stas</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
				<span class="n">stas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">stas</span>

	<span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span>

	<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">min_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_lon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_lon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_horizontal_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
			   <span class="n">max_horizontal_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_rd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_rd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_vertical_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
			   <span class="n">max_vertical_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_num_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_num_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">highpass_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Filter this event list by location properties and return a new event list object &quot;&quot;&quot;</span>

		<span class="n">NEW</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">min_t</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">min_t</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_t</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">max_t</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_lat</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_lats</span><span class="p">()</span><span class="o">&gt;</span><span class="n">min_lat</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_lat</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_lats</span><span class="p">()</span><span class="o">&lt;</span><span class="n">max_lat</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_lon</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_lons</span><span class="p">()</span><span class="o">&gt;</span><span class="n">min_lon</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_lon</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_lons</span><span class="p">()</span><span class="o">&lt;</span><span class="n">max_lon</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_horizontal_scatter</span><span class="p">:</span>
			<span class="n">d_xy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">horizontal_scatter</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">d_xy</span><span class="o">&gt;</span><span class="n">min_horizontal_scatter</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_horizontal_scatter</span><span class="p">:</span>
			<span class="n">d_xy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">horizontal_scatter</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">d_xy</span><span class="o">&lt;</span><span class="n">max_horizontal_scatter</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_depth</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_depths</span><span class="p">()</span><span class="o">&gt;</span><span class="n">min_depth</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_depth</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_depths</span><span class="p">()</span><span class="o">&lt;</span><span class="n">max_depth</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_rd</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_reduced_displacement</span><span class="p">()</span><span class="o">&gt;</span><span class="n">min_rd</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_rd</span><span class="p">:</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">NEW</span><span class="o">.</span><span class="n">get_reduced_displacement</span><span class="p">()</span><span class="o">&lt;</span><span class="n">max_rd</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_vertical_scatter</span><span class="p">:</span>
			<span class="n">d_xy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">vertical_scatter</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">d_xy</span><span class="o">&gt;</span><span class="n">min_vertical_scatter</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_vertical_scatter</span><span class="p">:</span>
			<span class="n">d_xy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">vertical_scatter</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">d_xy</span><span class="o">&lt;</span><span class="n">max_vertical_scatter</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">min_num_channels</span><span class="p">:</span>
			<span class="n">num</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">num</span><span class="o">&gt;</span><span class="n">min_num_channels</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">max_num_channels</span><span class="p">:</span>
			<span class="n">num</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">num</span><span class="o">&lt;</span><span class="n">max_num_channels</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">highpass_loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">vals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">highpass_loc</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">highpass_loc</span><span class="p">:</span>
				<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">vals</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="o">~</span><span class="n">vals</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;events&#39;</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">NEW</span>
			<span class="c1"># return event_list(NEW.events.tolist())</span>

	<span class="k">def</span> <span class="nf">calc_reduced_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">st</span><span class="p">,</span><span class="n">XC</span><span class="p">,</span><span class="n">num_processors</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Method to calculate a reduced displacement for all locations in the events list. </span>
<span class="sd">			st             - Obspy Stream of data from which to calculate values</span>
<span class="sd">			XC             - XCOR object used to obtain locations within the event list</span>
<span class="sd">			num_processors - Optional integer to parallelize when set &gt;1, but this doesn&#39;t appear to be faster</span>
<span class="sd">			</span>
<span class="sd">			The method updates the &#39;reduced_displacement&#39; property in each location object. XC_loc can also do</span>
<span class="sd">			this internally while generating a location, but the idea with this method is to apply the calculation</span>
<span class="sd">			after obtaining all initial locations and throwing out bad locations via clustering or maximum horizontal</span>
<span class="sd">			scatter. That way you are spending computation time for events you won&#39;t ever use.</span>
<span class="sd">	    &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">num_processors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
			<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">num_processors</span><span class="p">)</span>
			<span class="n">new_windows</span><span class="o">=</span><span class="p">[]</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">latitude</span><span class="p">):</span>
					<span class="n">new_windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
			<span class="n">results</span><span class="o">=</span><span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="n">XC</span><span class="p">,</span><span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">win</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span><span class="n">win</span><span class="o">.</span><span class="n">endtime</span><span class="p">)))</span> <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="n">new_windows</span><span class="p">]</span>
			<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
			<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
			<span class="n">RD</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
			<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">rd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">RD</span><span class="p">):</span>
				<span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">times</span><span class="o">==</span><span class="n">new_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">starttime</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="o">=</span><span class="n">rd</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">latitude</span><span class="p">):</span>
					<span class="n">l</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="o">=</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">XC</span><span class="p">,</span><span class="n">st</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span><span class="n">l</span><span class="o">.</span><span class="n">endtime</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">max_scatter</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span><span class="n">rm_nan_loc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">rm_nan_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Method to remove locations from the &#39;detections&#39; event list. Returns a new copy.</span>

<span class="sd">		    max_scatter - maximum horizontal scatter allowed for a give location</span>
<span class="sd">		    rm_nan_loc  - if &#39;True&#39;, will remove all locations with NaN locations</span>
<span class="sd">		    rm_nan_err  - if &#39;True&#39;, will remove all locations with NaN horizontal_scatter</span>
<span class="sd">		                  (not appropriate if not bootstrapping to obtain horizontal_scatter,</span>
<span class="sd">		                   eg. bootstrap=1)</span>
<span class="sd">			inplace     - boolean flag to operate in place (True) or return a copy (False,default) </span>
<span class="sd">		&quot;&quot;&quot;</span> 

		<span class="n">errs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">horizontal_scatter</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="n">IND</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errs</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">rm_nan_loc</span><span class="p">:</span>
			<span class="n">lats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lats</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errs</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">lats</span><span class="p">[</span><span class="n">ind</span><span class="p">]):</span>
					<span class="n">IND</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">rm_nan_err</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errs</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">errs</span><span class="p">[</span><span class="n">ind</span><span class="p">]):</span>
					<span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">IND</span><span class="p">:</span>
						<span class="n">IND</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errs</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">errs</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="ow">and</span> <span class="n">errs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">&gt;</span><span class="n">max_scatter</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">IND</span><span class="p">:</span>
					<span class="n">IND</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

		<span class="n">events</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">IND</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">events</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">event_list</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">remove_highpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="n">NEW</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
		<span class="n">vals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">highpass_loc</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">])</span>
		<span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="o">~</span><span class="n">vals</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;events&#39;</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">NEW</span>


	<span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="mf">25.0</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Method to remove locations within a list that have identical starttimes</span>
<span class="sd">		    distance - maximum horizontal distance (km) below which the locations of events </span>
<span class="sd">		               with identical starttimes are averaged</span>
<span class="sd">		    inplace  - boolean flag to operate in place (True) or return a copy (False,default) </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">idx_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
		<span class="n">sorted_T_array</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>
		<span class="n">vals</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sorted_T_array</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">idx_sort</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
		<span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
		<span class="n">res</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

		<span class="n">IND</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
				<span class="n">xy1</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
				<span class="n">xy2</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
				<span class="n">dist</span> <span class="o">=</span> <span class="n">gps2dist_azimuth</span><span class="p">(</span><span class="n">xy1</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span><span class="n">xy1</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span><span class="n">xy2</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span><span class="n">xy2</span><span class="o">.</span><span class="n">longitude</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.</span>
				<span class="k">if</span> <span class="n">dist</span><span class="o">&lt;</span><span class="n">distance</span><span class="p">:</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
						<span class="n">ind</span> <span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
						<span class="n">ind</span> <span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
					<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
						<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">):</span>
							<span class="n">ind</span> <span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
						<span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">)</span> <span class="ow">and</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">):</span>
							<span class="n">ind</span> <span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						<span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">):</span>
							<span class="n">ind</span> <span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="n">scatter</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">horizontal_scatter</span><span class="p">])</span>
							<span class="n">ind</span> <span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="n">scatter</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
					<span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">IND</span><span class="p">:</span>
						<span class="n">IND</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
		<span class="n">events</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">IND</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">events</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">event_list</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span><span class="n">num_events</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
		<span class="n">det</span><span class="o">=</span><span class="n">detections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
		<span class="n">det</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span><span class="n">num_events</span><span class="o">=</span><span class="n">num_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">det</span>


	<span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">event_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Return a copy of the events object &quot;&quot;&quot;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">detections</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; &#39;detections&#39; object. Contains different &#39;event_list&#39; objects as properties. This</span>
<span class="sd">	    object allows for lists all events, clustered events, and unclustered events to </span>
<span class="sd">	    exist all in one place and be modified using the same class methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">detects</span><span class="o">=</span><span class="p">[]):</span>
		<span class="k">if</span> <span class="n">detects</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;list&#39;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">=</span><span class="n">event_list</span><span class="p">(</span><span class="n">detects</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">detects</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;event_list&#39;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">=</span><span class="n">detects</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
		<span class="n">A</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">+</span><span class="s1">&#39;: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">events</span><span class="p">))</span> <span class="o">+</span><span class="s1">&#39; events&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="s1">&#39;DETECTION object with attributes:</span><span class="se">\n</span><span class="s1">(&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

	<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">min_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_lon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_lon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_horizontal_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
		   <span class="n">max_horizontal_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_rd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_rd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_vertical_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
		   <span class="n">max_vertical_scatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">min_num_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_num_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Filter each event_list in the detections object by location properties and return a new detections object</span>
<span class="sd">			with modified event_lists &quot;&quot;&quot;</span>
		<span class="n">NEW</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">a</span><span class="o">=</span><span class="n">NEW</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="n">NEW</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">min_t</span><span class="o">=</span><span class="n">min_t</span><span class="p">,</span><span class="n">max_t</span><span class="o">=</span><span class="n">max_t</span><span class="p">,</span><span class="n">min_lat</span><span class="o">=</span><span class="n">min_lat</span><span class="p">,</span><span class="n">max_lat</span><span class="o">=</span><span class="n">max_lat</span><span class="p">,</span><span class="n">min_lon</span><span class="o">=</span><span class="n">min_lon</span><span class="p">,</span>
											  <span class="n">max_lon</span><span class="o">=</span><span class="n">max_lon</span><span class="p">,</span><span class="n">min_horizontal_scatter</span><span class="o">=</span><span class="n">min_horizontal_scatter</span><span class="p">,</span><span class="n">max_horizontal_scatter</span><span class="o">=</span><span class="n">max_horizontal_scatter</span><span class="p">,</span>
											  <span class="n">min_depth</span><span class="o">=</span><span class="n">min_depth</span><span class="p">,</span><span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span><span class="n">min_rd</span><span class="o">=</span><span class="n">min_rd</span><span class="p">,</span><span class="n">max_rd</span><span class="o">=</span><span class="n">max_rd</span><span class="p">,</span><span class="n">min_vertical_scatter</span><span class="o">=</span><span class="n">min_vertical_scatter</span><span class="p">,</span>
		   									  <span class="n">max_vertical_scatter</span><span class="o">=</span><span class="n">max_vertical_scatter</span><span class="p">,</span><span class="n">min_num_channels</span><span class="o">=</span><span class="n">min_num_channels</span><span class="p">,</span><span class="n">max_num_channels</span><span class="o">=</span><span class="n">max_num_channels</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NEW</span>


	<span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">num_events</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Cluster locations in the &#39;detections&#39; event_list using &#39;DBSCAN&#39;. </span>
<span class="sd">		    dx          - the maximum horizontal distance in km</span>
<span class="sd">		    dt			- the maximum time difference between detections</span>
<span class="sd">		    num_events  - number of events required to meet the distance criteria</span>

<span class="sd">		    The method leaves the &#39;detections&#39; event_list untouched, but adds additional </span>
<span class="sd">		    event_list properties in place: </span>
<span class="sd">		    core_clustered - events who all meet the criteria</span>
<span class="sd">		    edge_clustered - events within &#39;eps&#39; distance of &#39;core_clustered&#39; event, but</span>
<span class="sd">		                     don&#39;t themselves have num_events within &#39;eps&#39; distance</span>
<span class="sd">		                     of them</span>
<span class="sd">		    noise          - events that don&#39;t meet either criteria above</span>
<span class="sd">		    all_clustered  - core_clustered + edge_clustered combined for convenience </span>
<span class="sd">	    &quot;&quot;&quot;</span>

		<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
		<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">latlon2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="ow">not</span> <span class="n">dt</span><span class="p">:</span>
			<span class="n">X</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># scale time to match distance</span>
			<span class="n">t</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">dtime</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">t0</span><span class="o">.</span><span class="n">datetime</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span><span class="o">/</span><span class="mf">60.</span> <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="n">t</span><span class="p">])</span>
			<span class="n">dtime</span>  <span class="o">=</span> <span class="n">dtime</span><span class="o">*</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>
			<span class="c1"># put distance and time together</span>
			<span class="n">X</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">dtime</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

		<span class="n">db</span>  <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">num_events</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

		<span class="n">all_detects</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">labels_</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">tmp</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">all_detects</span><span class="p">:</span>
			<span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">all_clustered</span><span class="o">=</span><span class="n">event_list</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

		<span class="n">tmp</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">core_sample_indices_</span><span class="p">:</span>
			<span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">core_clustered</span><span class="o">=</span><span class="n">event_list</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

		<span class="n">tmp</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">all_detects</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">db</span><span class="o">.</span><span class="n">core_sample_indices_</span><span class="p">:</span>
				<span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">edge_clustered</span><span class="o">=</span><span class="n">event_list</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

		<span class="n">tmp</span><span class="o">=</span><span class="p">[]</span>
		<span class="n">noise_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">labels_</span><span class="o">==-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">noise_inds</span><span class="p">:</span>
			<span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detections</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="o">=</span><span class="n">event_list</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">uncluster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Method to remove all event lists not named &#39;detections&#39;. Operates in place. &quot;&quot;&quot;</span>
		<span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s1">&#39;detections&#39;</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">max_scatter</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span><span class="n">rm_nan_loc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">rm_nan_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Method to remove locations from the &#39;detections&#39; event list. Returns a new copy.</span>

<span class="sd">		    max_scatter - maximum horizontal scatter allowed for a give location</span>
<span class="sd">		    rm_nan_loc  - if &#39;True&#39;, will remove all locations with NaN locations</span>
<span class="sd">		    rm_nan_err  - if &#39;True&#39;, will remove all locations with NaN horizontal_scatter</span>
<span class="sd">		                  (not appropriate if not bootstrapping to obtain horizontal_scatter,</span>
<span class="sd">		                   eg. bootstrap=1)</span>
<span class="sd">			inplace     - boolean flag to operate in place (True) or return a copy (False,default) </span>
<span class="sd">		&quot;&quot;&quot;</span> 

		<span class="n">NEW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">NEW</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="n">NEW</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">max_scatter</span><span class="o">=</span><span class="n">max_scatter</span><span class="p">,</span><span class="n">rm_nan_loc</span><span class="o">=</span><span class="n">rm_nan_loc</span><span class="p">,</span><span class="n">rm_nan_err</span><span class="o">=</span><span class="n">rm_nan_err</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">NEW</span>

	<span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="mf">25.0</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Method to remove locations within a list that have identical starttimes</span>
<span class="sd">		    distance - maximum horizontal distance (km) below which the locations of events </span>
<span class="sd">		               with identical starttimes are averaged</span>
<span class="sd">		    inplace  - boolean flag to operate in place (True) or return a copy (False,default) </span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">NEW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">NEW</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="n">NEW</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">remove_duplicates</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">NEW</span>

	<span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
		<span class="n">NEW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">NEW</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="nb">setattr</span><span class="p">(</span><span class="n">NEW</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">NEW</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot add unlike objects&#39;</span><span class="p">)</span>
				<span class="k">return</span>
		<span class="k">return</span> <span class="n">NEW</span>


<div class="viewcode-block" id="XCOR"><a class="viewcode-back" href="../../xcor.html#XC_loc.XC_main.XCOR">[docs]</a><span class="k">class</span> <span class="nc">XCOR</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	XCOR is the main class object that needs to be set up in order to get a location.</span>
<span class="sd">	Most of the paramater will self-assign, and in many cases that is fine. The only</span>
<span class="sd">	essential variable is the obspy stream &#39;st&#39;, but you will likely want to give thought</span>
<span class="sd">	and care to the grid and velocity model.</span>
<span class="sd">	</span>
<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	</span>
<span class="sd">	st : stream, required</span>
<span class="sd">		Obspy stream of envelopes. Each trace must have stats.coordinates.latitude/longitude</span>
<span class="sd">	model : str, optional</span>
<span class="sd">		Obspy taup model or model file from which to calculate travel times.</span>
<span class="sd">		If this is not provided, a default file will be called.</span>
<span class="sd">	model_dir : str, optional</span>
<span class="sd">		Directory where model.npz file is place by obspy&#39;s taup program</span>
<span class="sd">		If not provided, it will default to within the XC_loc module directory</span>
<span class="sd">	grid_size : dict, optional</span>
<span class="sd">		A dict with keys &#39;lats&#39;, &#39;lons&#39;, and &#39;deps&#39; each of which are 1D monotonic numpy arrays. </span>
<span class="sd">		If unprovided, this will be created internally based on the extent of the input stations.</span>
<span class="sd">	detrend : boolean, optional</span>
<span class="sd">		True/False to force a demean on obspy stream `st` or not.</span>
<span class="sd">		Default = True</span>
<span class="sd">	regrid : boolean, optional</span>
<span class="sd">		Whether to reinterpolate location on finer grid.</span>
<span class="sd">		Default = True</span>
<span class="sd">	phase_types : list, optional</span>
<span class="sd">		list of phases for which to calculate travel times. Ultimate travel time</span>
<span class="sd">		used for each grid node for each station will be the minimum calculated</span>
<span class="sd">		from the phases in the list provided. Also accepts [&#39;Nkmps&#39;] where N is a </span>
<span class="sd">		constant velocity in km/s. This would be useful for inputing a surface wave </span>
<span class="sd">		velocity, for example. See obspy taup documentation for more details on phase </span>
<span class="sd">		nomenclature.</span>
<span class="sd">		Default = [ &#39;s&#39;, &#39;S&#39; ]</span>
<span class="sd">	normType : int, optional</span>
<span class="sd">		Integer 1 or 2 to use an L1 or L2 norm.</span>
<span class="sd">		Default = 1</span>
<span class="sd">	plot : boolean, optional</span>
<span class="sd">		Boolean flag to plot or not.</span>
<span class="sd">		Default = True.</span>
<span class="sd">	interact : boolean, optional</span>
<span class="sd">		Boolean flag to interact with plot or not.</span>
<span class="sd">		Default = True</span>
<span class="sd">	output : int, optional</span>
<span class="sd">		Interger from 0-3 controlling increasing level of messages the code produces</span>
<span class="sd">		Default = 1</span>
<span class="sd">	Cmin : float, optional</span>
<span class="sd">		Minimum normalized cross-correlation coefficient to be considered.</span>
<span class="sd">		Default = 0.5</span>
<span class="sd">	Cmax : float, optional</span>
<span class="sd">		Maximum normalized cross-correlation coefficient to be considered. Not always </span>
<span class="sd">		necessary, but could be for removing correlated noise spikes, for example.</span>
<span class="sd">		Default = 0.995</span>
<span class="sd">	sta_min : int, optional</span>
<span class="sd">		Minimum number of stations needed to obtain a location.</span>
<span class="sd">		Default = 3</span>
<span class="sd">	dx_min : float, optional</span>
<span class="sd">		Minimum horizontal distance (km) between channels required to consider th</span>
<span class="sd">		cross-correlation. Useful to exclude correlations between multiple channels</span>
<span class="sd">		at the same station.</span>
<span class="sd">		Default = 0.1</span>
<span class="sd">	bootstrap : int, optional</span>
<span class="sd">		Number of iterations for each location. For each iteration, &#39;bootstrap_prct&#39;</span>
<span class="sd">		of the CC values will be zeroed out, and the resulting station contributions</span>
<span class="sd">		are adjusted accordingly to obtain a new location. These iterated locations</span>
<span class="sd">		provide a measure of location scatter, which is recorded in the location object.</span>
<span class="sd">		The final location will use all of the data (no CC values zeroed out). Thus,</span>
<span class="sd">		if boootstrap=N, it will bootstrap N times and get a location using all the data</span>
<span class="sd">		on the N+1 iteration. If bootstrap==1, the data are only located once with all the</span>
<span class="sd">		data, and no horizontal scatter is estimated.</span>
<span class="sd">		Default = 1</span>
<span class="sd">	bootstrap_prct : float, optional</span>
<span class="sd">		Value between 0 and 1 determining the fraction of cc data to throw out in each</span>
<span class="sd">		bootstrap iteration.</span>
<span class="sd">		Default = 0.04 (4%)</span>
<span class="sd">	lookup_type : str, optional</span>
<span class="sd">		Type of interpolation method to use when getting a predicted cross-correlation</span>
<span class="sd">		value for each channel pair for each grid (&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, </span>
<span class="sd">		&#39;quadratic&#39;, &#39;cubic&#39;). See scipy.interpolate.interp1d for details.</span>
<span class="sd">		Default=&#39;cubic&#39;</span>
<span class="sd">	rotation : dict, optinal</span>
<span class="sd">		Dictionary defining desired rotated grid. Needs keys &#39;x&#39; (x grid nodes), </span>
<span class="sd">		&#39;y&#39; (y grid nodes), &#39;z&#39; (depth grid nodes), &#39;lat0&#39; &amp; &#39;lon0&#39; (origin lat/lon),</span>
<span class="sd">		&#39;az&#39;, rotation azimuth (counterclockwise from East)</span>
<span class="sd">		Default = None</span>
<span class="sd">	dTmax_s : float, optional</span>
<span class="sd">		Maximum cross-correlation shift in seconds. Defaults to the smaller of:</span>
<span class="sd">			a) 1/2 of the obspy stream window length</span>
<span class="sd">			b) the maximum predicted inter-station differential time + `dt`</span>
<span class="sd">	dt : float, optional</span>
<span class="sd">		Seconds of additional allowed cross-correlation shifts beyond the maximumpredicted </span>
<span class="sd">		interchannel differential time. </span>
<span class="sd">		Default = 3.0</span>
<span class="sd">	rd_freq	: float, optional</span>
<span class="sd">		Frequency at which to calculate surface wave reduced displacement using the</span>
<span class="sd">		velocity from the top layer of the velocity model. If not set, body wave reduced </span>
<span class="sd">		displacement will be calculated.</span>
<span class="sd">		Default = None</span>
<span class="sd">	raw_traces : stream, optional</span>
<span class="sd">		Obpsy stream of non-envelope traces matching the input `st` variable. Used to</span>
<span class="sd">		calculate reduced displacement.</span>
<span class="sd">		Default = []</span>
<span class="sd">	env_hp : stream, optional</span>
<span class="sd">		Obspy stream of second envelopes with traces matchin the input `st` variable.</span>
<span class="sd">		This would typically be envelopes generated in a different passband than `st`.</span>
<span class="sd">		If a location is obtained for st, it will also check env_hp and set a flag.</span>
<span class="sd">		This can be useful for weeding out earthquake detections or correlated noise</span>
<span class="sd">		spikes when you are only interested in detecting a band-limited signal. It</span>
<span class="sd">		essentially gives you a way to flag windows where you have coherent energy in</span>
<span class="sd">		two different passbands. Kind of a niche-use case, but necessary for my needs.</span>
<span class="sd">		Default = []</span>
<span class="sd">	edge_control : float, optional</span>
<span class="sd">		Value between 0 and 1 defining a percentage from the window edge to not allow</span>
<span class="sd">		the peak trace energy. That is, if any trace&#39;s peak amplitude occurs between a</span>
<span class="sd">		with a percentage of the window edge, it is removed. Useful when autolocating.</span>
<span class="sd">		Default = 0.03</span>
<span class="sd">	num_processors : int, optional</span>
<span class="sd">		Number of processors to use if you are iterating through sliding windows to </span>
<span class="sd">		get locations. This can also be set in the `locate()` method.</span>
<span class="sd">		Default = 1.</span>
<span class="sd">	tt_file : str, optional</span>
<span class="sd">		Path to a .npz file containing pre-calculated traveltimes for this station set</span>
<span class="sd">		on this grid. Calulated using `save_traveltimes()` method.</span>
<span class="sd">		Default = None</span>
<span class="sd">	waveform_loc : boolean, optional</span>
<span class="sd">		Boolean flag to optionally locate waveforms rather than envelopes.</span>
<span class="sd">		This flag exists to bypass some of the built in envelope quailty control	</span>
<span class="sd">		Default = False</span>
<span class="sd">	gap_value : int, optional</span>
<span class="sd">		Value used to flag data gaps identified in preprocessing.</span>
<span class="sd">		Default = -123454321</span>

<span class="sd">	return : object</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">st</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">grid_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">detrend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">regrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">phase_types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">],</span>
				 	     <span class="n">normType</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">interact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
				 	     <span class="n">Cmin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">Cmax</span><span class="o">=</span><span class="mf">0.995</span><span class="p">,</span><span class="n">sta_min</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dx_min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span><span class="n">bootstrap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
				 	     <span class="n">bootstrap_prct</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span><span class="n">lookup_type</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span><span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dTmax_s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
				 	     <span class="n">rd_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">raw_traces</span><span class="o">=</span><span class="p">[],</span><span class="n">env_hp</span><span class="o">=</span><span class="p">[],</span><span class="n">edge_control</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span><span class="n">num_processors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
						 <span class="n">tt_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">waveform_loc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">model_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">gap_value</span><span class="o">=-</span><span class="mi">123454321</span><span class="p">):</span>

		<span class="k">if</span> <span class="n">output</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
			<span class="n">output</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">elif</span> <span class="n">output</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
			<span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">output</span>    <span class="o">=</span> <span class="n">output</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">traces</span>    <span class="o">=</span> <span class="n">st</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">detrend</span>   <span class="o">=</span> <span class="n">detrend</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">rotation</span>  <span class="o">=</span> <span class="n">rotation</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">tt_file</span><span class="p">:</span>
			<span class="kn">import</span> <span class="nn">os</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">model_dir</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="o">=</span><span class="n">model_dir</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning!  No model provided.&#39;</span><span class="p">)</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Default model used. Maybe not ideal...&#39;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;/default_vel_model.tvel&#39;</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Using &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">=</span><span class="n">model</span>

			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">phase_types</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
				<span class="n">phase_types</span><span class="o">=</span><span class="p">[</span><span class="n">phase_types</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span> <span class="o">=</span> <span class="n">phase_types</span>

			<span class="k">if</span> <span class="n">grid_size</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">=</span><span class="n">grid_size</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span><span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span><span class="s1">&#39;deps&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]})</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;lats&#39;</span><span class="p">:[],</span><span class="s1">&#39;lons&#39;</span><span class="p">:[],</span><span class="s1">&#39;deps&#39;</span><span class="p">:[]})</span>
					<span class="kn">from</span> <span class="nn">obspy.geodetics.base</span> <span class="kn">import</span> <span class="n">gps2dist_azimuth</span>

					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning!  No grid provided.&#39;</span><span class="p">)</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Making grid based on stations provided...&#39;</span><span class="p">)</span>

					<span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">latitude</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
					<span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">longitude</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
					<span class="n">dlat</span> <span class="o">=</span> <span class="mf">0.33</span><span class="o">*</span><span class="p">(</span><span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
					<span class="n">dlon</span> <span class="o">=</span> <span class="mf">0.33</span><span class="o">*</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">dlat</span><span class="p">,</span><span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">dlat</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">dlon</span><span class="p">,</span><span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">dlon</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>
					<span class="n">tmp</span> <span class="o">=</span> <span class="n">gps2dist_azimuth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
										   <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
					<span class="n">max_depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="mf">60.</span><span class="p">])</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_depth</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_traveltimes</span><span class="p">()</span>

			<span class="k">if</span> <span class="s1">&#39;kmps&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_v0</span>     <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;kmps&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_v0</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">v_mod</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">load_traveltimes</span><span class="p">(</span><span class="n">tt_file</span><span class="p">)</span>
			<span class="k">if</span> <span class="s1">&#39;kmps&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_v0</span>     <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;kmps&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_v0</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">regrid</span>      <span class="o">=</span> <span class="n">regrid</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_normType</span>   <span class="o">=</span> <span class="n">normType</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">plot</span>        <span class="o">=</span> <span class="n">plot</span>
		
		<span class="bp">self</span><span class="o">.</span><span class="n">interact</span>    <span class="o">=</span> <span class="n">interact</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">interact</span> <span class="o">=</span> <span class="kc">False</span>
		
		<span class="bp">self</span><span class="o">.</span><span class="n">_p</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.9650</span><span class="p">,</span> <span class="o">-</span><span class="mf">18.9378</span><span class="p">,</span> <span class="mf">26.7329</span><span class="p">,</span> <span class="o">-</span><span class="mf">16.5927</span><span class="p">,</span> <span class="mf">3.8438</span><span class="p">])</span> <span class="c1"># weight polynomial coefficients</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">Cmin</span>        <span class="o">=</span> <span class="n">Cmin</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_Cmax</span>       <span class="o">=</span> <span class="n">Cmax</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_dx_min</span>     <span class="o">=</span> <span class="n">dx_min</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sta_min</span>     <span class="o">=</span> <span class="n">sta_min</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span>    <span class="o">=</span> <span class="n">bootstrap</span>
		<span class="k">if</span> <span class="n">bootstrap</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">=</span> <span class="n">bootstrap</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: </span><span class="se">\&#39;</span><span class="s1">bootstrap</span><span class="se">\&#39;</span><span class="s1"> value must be an integer &gt; 0&#39;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting bootstrap = 1&#39;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">=</span> <span class="mi">1</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_prct</span> <span class="o">=</span> <span class="n">bootstrap_prct</span>	
		<span class="k">if</span> <span class="n">lookup_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">]:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">lookup_type</span><span class="se">\&#39;</span><span class="s1"> needs to be: </span><span class="se">\&#39;</span><span class="s1">linear</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">nearest</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">zero</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">slinear</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">quadratic</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">cubic</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting lookup_type to </span><span class="se">\&#39;</span><span class="s1">cubic</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
			<span class="n">lookup_type</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">lookup_type</span>  <span class="o">=</span> <span class="n">lookup_type</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>         <span class="o">=</span> <span class="n">dt</span>
		
		<span class="k">if</span> <span class="n">dTmax_s</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span>     <span class="o">=</span> <span class="n">dTmax_s</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">seconds</span><span class="o">=</span><span class="p">[(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">seconds</span><span class="p">),</span><span class="n">xcorr_Tools</span><span class="o">.</span><span class="n">station_distances</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_v0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">])</span>

		<span class="n">dTmax</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>	<span class="c1"># can&#39;t make a total shift of more than dTmax samples	</span>
		<span class="c1"># self._mlag         = int(2*dTmax) # change on 0ct-30-2017</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_mlag</span>         <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dTmax</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="n">raw_traces</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">raw_traces</span> <span class="o">=</span> <span class="n">raw_traces</span>
			<span class="k">if</span> <span class="n">rd_freq</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">rd_freq</span> <span class="o">=</span> <span class="n">rd_freq</span>

		<span class="k">if</span> <span class="n">env_hp</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">env_hp</span> <span class="o">=</span> <span class="n">env_hp</span>
			<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env_hp</span><span class="p">:</span>
				<span class="n">tr</span><span class="o">.</span><span class="n">TT</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">TT</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_edge_control</span>   <span class="o">=</span> <span class="n">edge_control</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_num_processors</span> <span class="o">=</span> <span class="n">num_processors</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_waveform_loc</span>   <span class="o">=</span> <span class="n">waveform_loc</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_gap_value</span> <span class="o">=</span> <span class="n">gap_value</span>


	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
		<span class="n">A</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">+</span><span class="s1">&#39;=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)))</span>
		<span class="k">return</span> <span class="s1">&#39;parameters(&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>


<div class="viewcode-block" id="XCOR.calculate_traveltimes"><a class="viewcode-back" href="../../xcor.html#XC_loc.XC_main.XCOR.calculate_traveltimes">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_traveltimes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculate travel times based on the model and grid provided in the `XCOR` object</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="s1">&#39;default_vel_model&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">TauPyModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="o">+</span><span class="s1">&#39;/default_vel_model&#39;</span><span class="p">)</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="kn">from</span> <span class="nn">obspy.taup.taup_create</span> <span class="kn">import</span> <span class="n">build_taup_model</span>
				<span class="n">build_taup_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="p">,</span><span class="n">output_folder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.tvel&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">TauPyModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;tvel&#39;</span><span class="p">:</span>
				<span class="kn">from</span> <span class="nn">obspy.taup.taup_create</span> <span class="kn">import</span> <span class="n">build_taup_model</span>
				<span class="n">build_taup_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="p">,</span><span class="n">output_folder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.tvel&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		
			<span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">TauPyModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_file</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;LON&#39;</span><span class="p">:[],</span><span class="s1">&#39;LAT&#39;</span><span class="p">:[],</span><span class="s1">&#39;DEP&#39;</span><span class="p">:[]})</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;DEP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xloc_Tools</span><span class="o">.</span><span class="n">create_rotated_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;DEP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">])</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">progress</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]),</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;complete&#39;</span><span class="p">)</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		if self.tt_calc==&#39;full&#39;:</span>
<span class="sd">			for i,tr in enumerate(self.traces):</span>
<span class="sd">				TIMES=[]</span>
<span class="sd">				for j,lon in enumerate(self._grid[&#39;LON&#39;].flatten()):</span>
<span class="sd">					deg=locations2degrees(tr.stats.coordinates.latitude,tr.stats.coordinates.longitude,self._grid[&#39;LAT&#39;].flatten()[j],lon)</span>
<span class="sd">					PATHS=self.model.get_ray_paths(source_depth_in_km=self._grid[&#39;DEP&#39;].flatten()[j],distance_in_degree=deg,receiver_depth_in_km=0,phase_list=self.phase_types)</span>
<span class="sd">					times=np.array([p.time for p in PATHS])</span>
<span class="sd">					TIMES.append(times.min())</span>

<span class="sd">				tr.TT=np.reshape(TIMES,self._grid[&#39;LON&#39;].shape)</span>
<span class="sd">				if self.output:</span>
<span class="sd">					progress(i+1, len(self.traces), status=&#39;complete&#39;)</span>
<span class="sd">		else: </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
			<span class="n">LON</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">][:,:,</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">LAT</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">][:,:,</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">LON</span><span class="p">,</span><span class="n">LAT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">])</span>

		<span class="n">lat_corners</span> <span class="o">=</span> <span class="n">LAT</span><span class="p">[::</span><span class="n">LAT</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="n">LAT</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">lon_corners</span> <span class="o">=</span> <span class="n">LON</span><span class="p">[::</span><span class="n">LON</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="n">LON</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">dist</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
			<span class="n">tr</span><span class="o">.</span><span class="n">TT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">LAT</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]),))</span>
			<span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lat_corners</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">lon_corners</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
				<span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locations2degrees</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>

		<span class="n">max_deg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
		<span class="n">DEGS</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_deg</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]):</span>

			<span class="n">TIMES</span><span class="o">=</span><span class="p">[]</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">DEGS</span><span class="p">:</span>
				<span class="n">PATHS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_ray_paths</span><span class="p">(</span><span class="n">source_depth_in_km</span><span class="o">=</span><span class="n">z</span><span class="p">,</span><span class="n">distance_in_degree</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">receiver_depth_in_km</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">phase_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="p">)</span>
					<span class="nb">print</span><span class="p">(</span><span class="n">PATHS</span><span class="p">)</span>
				<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">PATHS</span><span class="p">])</span>
				<span class="n">TIMES</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

			<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
				<span class="n">deg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">locations2degrees</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> 
													<span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">LAT</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">LON</span><span class="o">.</span><span class="n">flatten</span><span class="p">())])</span>
				<span class="n">inter_times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span><span class="n">DEGS</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">TIMES</span><span class="p">))</span>
				<span class="n">TIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">inter_times</span><span class="p">,</span><span class="n">LAT</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
				<span class="n">tr</span><span class="o">.</span><span class="n">TT</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">TIM</span>
			
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]),</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;complete&#39;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="XCOR.save_traveltimes"><a class="viewcode-back" href="../../xcor.html#XC_loc.XC_main.XCOR.save_traveltimes">[docs]</a>	<span class="k">def</span> <span class="nf">save_traveltimes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outfile</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Save an .npz file containing the model and grid. The variables should be created </span>
<span class="sd">		using the `calculate_traveltimes()` method, which is called internally  when initiating</span>
<span class="sd">		an XCOR object with a model and grid.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		file : str, required</span>
<span class="sd">			The .npz file you wish to save, ideally with full path provided.</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">v_mod</span><span class="o">.</span><span class="n">layers</span>
		<span class="n">phase_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span>
		<span class="n">deps</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
			<span class="n">Xs</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
			<span class="n">Ys</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">lats</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span>
			<span class="n">lons</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span>

		<span class="n">stas</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
			<span class="n">stas</span><span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">TT</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
			<span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">Ys</span><span class="p">,</span>     <span class="n">x</span><span class="o">=</span><span class="n">Xs</span><span class="p">,</span>     <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span><span class="n">phase_types</span><span class="o">=</span><span class="n">phase_types</span><span class="p">,</span><span class="n">stations</span><span class="o">=</span><span class="n">stas</span><span class="p">,</span><span class="o">**</span><span class="n">stas</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span><span class="n">lats</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span><span class="n">lons</span><span class="o">=</span><span class="n">lons</span><span class="p">,</span><span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span><span class="n">phase_types</span><span class="o">=</span><span class="n">phase_types</span><span class="p">,</span><span class="n">stations</span><span class="o">=</span><span class="n">stas</span><span class="p">,</span><span class="o">**</span><span class="n">stas</span><span class="p">)</span></div>


<div class="viewcode-block" id="XCOR.load_traveltimes"><a class="viewcode-back" href="../../xcor.html#XC_loc.XC_main.XCOR.load_traveltimes">[docs]</a>	<span class="k">def</span> <span class="nf">load_traveltimes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; </span>
<span class="sd">		Load an .npz file containing a model and grid, and assign the appropriate times</span>
<span class="sd">		to each trace in the object. The .npz file can be created initially using the</span>
<span class="sd">		`save_traveltimes()` method after `XCOR` has run `calculate_traveltimes()` with a model and grid.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		file : str, required</span>
<span class="sd">			The path/filename to the .npz file you wish to load</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">npzfile</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;LON&#39;</span><span class="p">:[],</span><span class="s1">&#39;LAT&#39;</span><span class="p">:[],</span><span class="s1">&#39;DEP&#39;</span><span class="p">:[]})</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span>   <span class="p">:</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span>
							<span class="s1">&#39;y&#39;</span>   <span class="p">:</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span>
							<span class="s1">&#39;deps&#39;</span><span class="p">:</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]}</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;DEP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xloc_Tools</span><span class="o">.</span><span class="n">create_rotated_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;lons&#39;</span><span class="p">:</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">],</span>
							<span class="s1">&#39;lats&#39;</span><span class="p">:</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">],</span>
							<span class="s1">&#39;deps&#39;</span><span class="p">:</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">]}</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;DEP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">[</span><span class="s1">&#39;deps&#39;</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_model_layers</span><span class="o">=</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">phase_types</span><span class="o">=</span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;phase_types&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
			<span class="n">tr</span><span class="o">.</span><span class="n">TT</span><span class="o">=</span><span class="n">npzfile</span><span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">TT</span><span class="p">)</span><span class="o">!=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">]):</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error loading file. Dimension mismatch for station &#39;</span><span class="o">+</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></div>


<div class="viewcode-block" id="XCOR.locate"><a class="viewcode-back" href="../../xcor.html#XC_loc.XC_main.XCOR.locate">[docs]</a>	<span class="k">def</span> <span class="nf">locate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">window_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">include_partial_windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dTmax_s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">num_processors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; </span>
<span class="sd">		Main method to locate data provided. This method is actually a wrapper to call main envelope </span>
<span class="sd">		cross correlation location algorithm `XC_locate`.</span>
<span class="sd">		</span>
<span class="sd">		If using this to locate a single window of data, simply call locate() with no input parameters.</span>
<span class="sd">		All of the relevant details (plot, interact, map_resolution) are properties set in the initial</span>
<span class="sd">		object creation. If using this to iterate over windows and locate, the following parameters must be set:</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		window_length : float, optional</span>
<span class="sd">			Length of each sub-window in seconds.</span>
<span class="sd">			Default = None</span>
<span class="sd">		step : float, optional</span>
<span class="sd">			The step between the start times of two successive windows in seconds. Can be negative if an offset is given.</span>
<span class="sd">			Default = None</span>


<span class="sd">		These parameters are optional:</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		offset : float, optional</span>
<span class="sd">			The offset of the first window in seconds relative to the start time of the whole interval.</span>
<span class="sd">			Default = False</span>
<span class="sd">		include_partial_windows : boolean, optional</span>
<span class="sd">			Determines if sub-windows that are shorter then 99.9 % of the desired length are returned.</span>
<span class="sd">		nearest_sample : boolean, optional</span>
<span class="sd">			If set to True, the closest sample is selected, if set to False, the inner (next sample for a </span>
<span class="sd">			start time border, previous sample for an end time border) sample containing the time is selected.</span>
<span class="sd">			Default = True</span>
<span class="sd">		dTmax_s : float, optional</span>
<span class="sd">			Maximum cross-correlation shift in seconds. Defaults to the smaller of:</span>
<span class="sd">				a) 1/2 of the obspy stream sub-window length</span>
<span class="sd">				b) the maximum predicted inter-station differential time + &#39;dt&#39;, set during initial object creation</span>
<span class="sd">		num_processors : int, optional</span>
<span class="sd">			Number of processors to use in parallel</span>
<span class="sd">			Default = None</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">num_processors</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_num_processors</span><span class="o">=</span><span class="n">num_processors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">window_length</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">dTmax_s</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span> <span class="o">=</span> <span class="n">dTmax_s</span>
				<span class="n">dTmax</span> 	     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>	<span class="c1"># can&#39;t make a total shift of more than dTmax samples	</span>
				<span class="c1"># self._mlag         = int(2*dTmax) # change on 0ct-30-2017</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_mlag</span>         <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dTmax</span><span class="p">)</span>
			
			<span class="n">loc</span><span class="o">=</span><span class="n">XC_locate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">),</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_windows</span><span class="o">=</span><span class="kc">True</span>
			<span class="k">if</span> <span class="n">dTmax_s</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span> <span class="o">=</span> <span class="n">dTmax_s</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">window_length</span><span class="p">,</span><span class="n">xcorr_Tools</span><span class="o">.</span><span class="n">station_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_v0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">])</span>

			<span class="n">dTmax</span> 	   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dTmax_s</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>	<span class="c1"># can&#39;t make a total shift of more than dTmax samples	</span>
			<span class="c1"># self._mlag         = int(2*dTmax) # change on 0ct-30-2017</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_mlag</span>         <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dTmax</span><span class="p">)</span>

			<span class="k">if</span> <span class="ow">not</span> <span class="n">step</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Set step size&#39;</span><span class="p">)</span>
				<span class="k">return</span>

			<span class="kn">from</span> <span class="nn">obspy.core.util.misc</span> <span class="kn">import</span> <span class="n">get_window_times</span>
			<span class="n">windows</span> <span class="o">=</span> <span class="n">get_window_times</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span><span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span><span class="n">window_length</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span>
									   <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">include_partial_windows</span><span class="o">=</span><span class="n">include_partial_windows</span><span class="p">)</span>

			<span class="n">bp_traces</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="k">if</span> <span class="s1">&#39;env_hp&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
				<span class="n">env_hp</span><span class="o">=</span><span class="kc">True</span>
				<span class="n">hp_traces</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env_hp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">env_hp</span>   <span class="o">=</span> <span class="p">[]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">env_hp</span><span class="o">=</span><span class="kc">False</span>

			<span class="k">if</span> <span class="s1">&#39;raw_traces&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
				<span class="n">rd_flag</span>    <span class="o">=</span> <span class="kc">True</span>
				<span class="n">raw_traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_traces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="s1">&#39;raw_traces&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">rd_flag</span>    <span class="o">=</span> <span class="kc">False</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_processors</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
				<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
				<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_processors</span><span class="p">)</span>
				<span class="n">results</span><span class="o">=</span><span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">XC_locate</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="bp">self</span><span class="p">))</span> <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">]</span>

				<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
				<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
				<span class="n">loc</span><span class="o">=</span><span class="n">event_list</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
				
				<span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">=</span><span class="p">[]</span>
				<span class="k">if</span> <span class="n">env_hp</span><span class="p">:</span>
					<span class="n">new_windows</span><span class="o">=</span><span class="p">[]</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">):</span>
						<span class="n">l</span><span class="o">.</span><span class="n">highpass_loc</span><span class="o">=</span><span class="kc">False</span>
						<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">latitude</span><span class="p">):</span>
							<span class="n">new_windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating highpass locations for </span><span class="si">{:.0f}</span><span class="s1"> locations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_windows</span><span class="p">)))</span>
					<span class="n">tmp_bootstrap</span>  <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)</span>
					<span class="n">tmp_regrid</span>     <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">traces</span>    <span class="o">=</span> <span class="n">hp_traces</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">=</span> <span class="mi">10</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">regrid</span>    <span class="o">=</span> <span class="kc">False</span>

					<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_processors</span><span class="p">)</span>
					<span class="n">results</span><span class="o">=</span><span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">XC_locate</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="bp">self</span><span class="p">))</span> <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="n">new_windows</span><span class="p">]</span>
					<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
					<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
					<span class="c1"># loc_hp=event_list([p.get() for p in results]).remove(max_scatter=10)</span>
					<span class="n">loc_hp</span><span class="o">=</span><span class="n">event_list</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
					<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loc_hp</span><span class="o">.</span><span class="n">events</span><span class="p">))</span>
					<span class="n">loc_hp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">max_scatter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">rm_nan_loc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">rm_nan_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
					<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loc_hp</span><span class="o">.</span><span class="n">events</span><span class="p">))</span>
					<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
					<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">loc_hp</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
						<span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">times</span><span class="o">==</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">highpass_loc</span><span class="o">=</span><span class="kc">True</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">=</span><span class="p">[]</span>

				<span class="k">if</span> <span class="n">rd_flag</span><span class="p">:</span>
					<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_processors</span><span class="p">)</span>
					<span class="n">new_windows</span><span class="o">=</span><span class="p">[]</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">):</span>
						<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">latitude</span><span class="p">):</span>
							<span class="n">new_windows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">l</span><span class="p">))</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating reduced displacement for </span><span class="si">{:.0f}</span><span class="s1"> locations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_windows</span><span class="p">)))</span>
					<span class="n">results</span><span class="o">=</span><span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="p">,</span><span class="n">raw_traces</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span> <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="n">new_windows</span><span class="p">]</span>
					<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
					<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
					<span class="n">RD</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="n">env_hp</span><span class="p">:</span>
						<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">rd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">RD</span><span class="p">):</span>
						<span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">times</span><span class="o">==</span><span class="n">new_windows</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="o">=</span><span class="n">rd</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">raw_traces</span> <span class="o">=</span> <span class="n">raw_traces</span>

			<span class="k">else</span><span class="p">:</span>
				<span class="n">loc</span><span class="o">=</span><span class="n">event_list</span><span class="p">([</span><span class="n">XC_locate</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">env_hp</span><span class="p">:</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating highpass locations...&#39;</span><span class="p">)</span>
					<span class="n">tmp_bootstrap</span>  <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">)</span>
					<span class="n">tmp_regrid</span>     <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">traces</span>    <span class="o">=</span> <span class="n">hp_traces</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">=</span> <span class="mi">10</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">regrid</span>    <span class="o">=</span> <span class="kc">False</span>
					<span class="n">loc_hp</span><span class="o">=</span><span class="p">[]</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">):</span>
						<span class="n">l</span><span class="o">.</span><span class="n">highpass_loc</span><span class="o">=</span><span class="kc">False</span>
						<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">latitude</span><span class="p">):</span>
							<span class="n">loc_hp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">XC_locate</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="p">))</span>
					<span class="n">loc_hp</span><span class="o">=</span><span class="n">event_list</span><span class="p">(</span><span class="n">loc_hp</span><span class="p">)</span>
					<span class="n">loc_hp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">max_scatter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">rm_nan_loc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">rm_nan_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
					<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
					<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">loc_hp</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
						<span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">times</span><span class="o">==</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">highpass_loc</span><span class="o">=</span><span class="kc">True</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">=</span><span class="p">[]</span>
				<span class="k">if</span> <span class="n">rd_flag</span><span class="p">:</span>
					<span class="n">new_windows</span><span class="o">=</span><span class="p">[]</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">):</span>
						<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">latitude</span><span class="p">):</span>
							<span class="n">new_windows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">l</span><span class="p">))</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating reduced displacement for </span><span class="si">{:.0f}</span><span class="s1"> locations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_windows</span><span class="p">)))</span>
					<span class="n">RD</span><span class="o">=</span><span class="p">[</span><span class="n">xloc_Tools</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="p">,</span><span class="n">raw_traces</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="n">new_windows</span><span class="p">]</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="n">env_hp</span><span class="p">:</span>
						<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">get_times</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">rd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">RD</span><span class="p">):</span>
						<span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">times</span><span class="o">==</span><span class="n">new_windows</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">loc</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_displacement</span><span class="o">=</span><span class="n">rd</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">raw_traces</span> <span class="o">=</span> <span class="n">raw_traces</span>
			
			<span class="bp">self</span><span class="o">.</span><span class="n">traces</span>    <span class="o">=</span> <span class="n">bp_traces</span>
			<span class="k">if</span> <span class="n">env_hp</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">env_hp</span>    <span class="o">=</span> <span class="n">hp_traces</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">bootstrap</span> <span class="o">=</span> <span class="n">tmp_bootstrap</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">regrid</span>    <span class="o">=</span> <span class="n">tmp_regrid</span>

		<span class="k">return</span> <span class="n">loc</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Aaron Wech

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>